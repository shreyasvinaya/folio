<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://shreyasvinaya.github.io/folio/feed.xml" rel="self" type="application/atom+xml"/><link href="https://shreyasvinaya.github.io/folio/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-07-10T15:05:43+00:00</updated><id>https://shreyasvinaya.github.io/folio/feed.xml</id><title type="html">blank</title><subtitle>Personal Website of Shreyas V </subtitle><entry><title type="html">Principles of Programming Languages notes</title><link href="https://shreyasvinaya.github.io/folio/blog/2023/principles-of-language/" rel="alternate" type="text/html" title="Principles of Programming Languages notes"/><published>2023-12-04T00:00:00+00:00</published><updated>2023-12-04T00:00:00+00:00</updated><id>https://shreyasvinaya.github.io/folio/blog/2023/principles-of-language</id><content type="html" xml:base="https://shreyasvinaya.github.io/folio/blog/2023/principles-of-language/"><![CDATA[<h1 id="rust">Rust</h1> <h2 id="programming-concepts">Programming Concepts</h2> <h3 id="variables-and-mutability">Variables and Mutability</h3> <ul> <li>Variables are immutable in Rust</li> <li>Declare them as <code class="language-plaintext highlighter-rouge">mut</code> if you want to assign a new value to it</li> <li>Variables are locked to the scope <ul> <li>They can have diff values in diff scopes <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">{</span>
      <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
      <span class="nd">println!</span><span class="p">(</span><span class="s">"The value of x is: {x}"</span><span class="p">);</span>
      <span class="cs"># The value of x is: 6</span>
  <span class="p">}</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"The value of x is: {x}"</span><span class="p">);</span>
  <span class="cs"># The value of x is: 5</span>
</code></pre></div> </div> </li> <li>This is called shadowing</li> </ul> </li> <li>The keyword <code class="language-plaintext highlighter-rouge">let</code> can be used to change type of the variable <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">let</span> <span class="n">spaces</span> <span class="o">=</span> <span class="s">"   "</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">spaces</span> <span class="o">=</span> <span class="n">spaces</span><span class="nf">.len</span><span class="p">();</span>
</code></pre></div> </div> </li> </ul> <h3 id="data-types">Data Types</h3> <ul> <li>Rust is a statically typed language, which means that it must know the types of all variables at compile time</li> <li>You need not explicitly declare the variable type during declaration</li> <li>Supports tuple destructuring like python</li> <li>Memory is protected, incorrect index access is not allowed</li> </ul> <h3 id="functions">Functions</h3> <ul> <li>Use <code class="language-plaintext highlighter-rouge">fn</code> keyword to declare a function</li> <li>Use <code class="language-plaintext highlighter-rouge">-&gt;</code> to specify return type</li> <li>functions dont return values, they return expressions</li> </ul> <h3 id="comments">Comments</h3> <ul> <li><code class="language-plaintext highlighter-rouge">//</code> for single line comments</li> <li><code class="language-plaintext highlighter-rouge">/* */</code> for multiline comments</li> </ul> <h3 id="control-flow">Control Flow</h3> <ul> <li><code class="language-plaintext highlighter-rouge">if</code> is an expression</li> <li><code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">else</code> must return same type</li> <li><code class="language-plaintext highlighter-rouge">if</code> can be used in <code class="language-plaintext highlighter-rouge">let</code> statements</li> <li><code class="language-plaintext highlighter-rouge">loop</code> is an infinite loop</li> <li><code class="language-plaintext highlighter-rouge">while</code> is a conditional loop</li> </ul> <h2 id="ownership">Ownership</h2> <ul> <li>Central concept that the compiler uses to manage memory safely.</li> <li>Each value has a variable that is its owner.</li> <li>There can only be one owner at a time. When owner goes out of scope, value will be dropped (freed).</li> <li>Borrowing allows accessing data without taking ownership via references. References are immutable by default to avoid data races.</li> <li>Slices allow shared, mutable access to contiguous sequences like vectors.</li> </ul> <h3 id="what-is-ownership">What is Ownership?</h3> <ul> <li>Memory is managed through a system of ownership with a set of rules that the compiler checks at compile time</li> <li>Ownership rules: <ul> <li>Each value in Rust has a variable that’s called its owner</li> <li>There can only be one owner at a time</li> <li>When the owner goes out of scope, the value will be dropped</li> </ul> </li> <li>Rust never automatically creates “deep” copies of your data</li> <li>If you want to deeply copy the heap data of the String, not just the stack data, you can use a common method called <code class="language-plaintext highlighter-rouge">clone</code></li> <li>Stack only data: <ul> <li>fixed size</li> <li>popped off the stack when scope ends</li> </ul> </li> <li>Benefits of Ownership: <ul> <li>Prevents Memory Leaks</li> <li>Prevents Dangling pointers</li> <li>makes code more predictable</li> </ul> </li> </ul> <h3 id="references-and-borrowing">References and Borrowing</h3> <ul> <li>References allow you to refer to some value without taking ownership of it</li> <li>References are immutable by default but can be made mutable by using <code class="language-plaintext highlighter-rouge">&amp;mut</code></li> <li><code class="language-plaintext highlighter-rouge">&amp;</code> is used to create a reference</li> <li>We call having references as function parameters borrowing</li> <li>Borrowing is used to allow multiple readers or one writer of data at a time</li> <li>References must always be valid</li> <li>Valid references: <ul> <li>A reference to any value that is still in scope</li> <li>A reference to any value that has been moved to a new scope</li> </ul> </li> <li>Mutable references have one big restriction: if you have a mutable reference to a value, you can have no other references to that value.</li> <li>Dangling references are not allowed in Rust</li> <li>Dangerous references: <ul> <li>A reference to a value that has gone out of scope</li> <li>A reference to a value that has been freed</li> </ul> </li> </ul> <h3 id="slices">Slices</h3> <ul> <li>Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection</li> <li>Slice is a kind of reference, it does not have ownership</li> <li>we can slice strings, arrays, vectors</li> </ul> <p>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time.</p> <h2 id="enums-and-pattern-matching">Enums and Pattern Matching</h2> <ul> <li>Enums are a way of grouping related values so you can use them without spelling mistakes</li> <li>Enums can be used to create custom data types <h3 id="how-are-enums-different-from-struct">How are enums different from struct</h3> </li> <li>Enums are different from structs because you can only have one variant of an enum value at a time</li> <li>In an <code class="language-plaintext highlighter-rouge">enum</code>, each variant can have different types and amounts of associated data.</li> </ul> <h3 id="enums">Enums:</h3> <ul> <li>Enumerations can encode multiple variants for a type.</li> <li>Variants can have different data associated with them.</li> <li>Powerful pattern matching allows easy processing of different variants.</li> <li>Great for state machines, error handling, and sending messages between parts of a system.</li> </ul> <h2 id="packages-and-crates">Packages and Crates:</h2> <ul> <li>Crates are compilation units in Rust - can produce library or binary.</li> <li>Crates can be reused by importing them from other crates.</li> <li>Packages contain one or more crates for distribution.</li> <li>Module system provides private/public boundary within crate.</li> </ul> <h2 id="traits-and-generics">Traits and Generics:</h2> <ul> <li>Traits define shared behavior/interfaces that types can implement.</li> <li>Generics provide abstraction over types - functions/structs can work for multiple types.</li> <li>Combined, they provide flexibility to make code work with multiple types.</li> <li>Lifetimes explicitly annotate how references are valid.</li> </ul> <h2 id="error-handling">Error Handling:</h2> <ul> <li>Errors are core part of Rust philosophy. No exceptions.</li> <li>Enum error variants carry extra context.</li> <li>? operator handles propagating errors up call stack.</li> <li>Idiomatic to expect and handle errors rather than ignore.</li> </ul> <h2 id="notes">Notes</h2> <ol> <li>Getting Started -&gt; Ignore mostly</li> <li>Common programming concepts important</li> <li>Understanding ownership Slice type is important</li> <li>Using structs to structure related data <ol> <li>mildly important chapter. just skim through it</li> </ol> </li> <li>Enums and Pattern matching - VERY IMPORTANT</li> <li>Packaging, states and modules // VERY IMPORTANT - how is this different from c++</li> <li>Maps</li> <li>Error Handling Important //difference from Haskell</li> <li>Generic types, traits and Ifetime /MOST IMPORTANT CHAPTER</li> <li>Iterators and closures</li> <li>Smart pointers /IMPORTANT &gt; Exiension of ownership model</li> <li>Just skim over concurrency, not very imp</li> </ol>]]></content><author><name>Shreyas V</name></author><category term="notes"/><summary type="html"><![CDATA[notes for the course CS F301 Principles of Programming Languages]]></summary></entry><entry><title type="html">a post with github metadata</title><link href="https://shreyasvinaya.github.io/folio/blog/2020/github-metadata/" rel="alternate" type="text/html" title="a post with github metadata"/><published>2020-09-28T21:01:00+00:00</published><updated>2020-09-28T21:01:00+00:00</updated><id>https://shreyasvinaya.github.io/folio/blog/2020/github-metadata</id><content type="html" xml:base="https://shreyasvinaya.github.io/folio/blog/2020/github-metadata/"><![CDATA[<p>A sample blog page that demonstrates the accessing of github meta data.</p> <h2 id="what-does-github-metadata-do">What does Github-MetaData do?</h2> <ul> <li>Propagates the site.github namespace with repository metadata</li> <li>Setting site variables : <ul> <li>site.title</li> <li>site.description</li> <li>site.url</li> <li>site.baseurl</li> </ul> </li> <li>Accessing the metadata - duh.</li> <li>Generating edittable links.</li> </ul> <h2 id="additional-reading">Additional Reading</h2> <ul> <li>If you’re recieving incorrect/missing data, you may need to perform a Github API<a href="https://github.com/jekyll/github-metadata/blob/master/docs/authentication.md"> authentication</a>.</li> <li>Go through this <a href="https://jekyll.github.io/github-metadata/">README</a> for more details on the topic.</li> <li><a href="https://github.com/jekyll/github-metadata/blob/master/docs/site.github.md">This page</a> highlights all the feilds you can access with github-metadata. <br/></li> </ul> <h2 id="example-metadata">Example MetaData</h2> <ul> <li>Host Name :</li> <li>URL :</li> <li>BaseURL :</li> <li>Archived :</li> <li>Contributors :</li> </ul>]]></content><author><name></name></author><category term="sample-posts"/><category term="external-services"/><category term="metadata"/><summary type="html"><![CDATA[a quick run down on accessing github metadata.]]></summary></entry></feed>